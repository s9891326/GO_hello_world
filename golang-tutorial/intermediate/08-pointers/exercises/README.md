# 第八章練習題

## 練習 1：雙向鏈表實現

創建一個雙向鏈表數據結構：

要求：
- 實現雙向鏈表節點結構（包含前驅和後繼指針）
- 實現鏈表的基本操作：插入、刪除、查找、遍歷
- 支援正向和反向遍歷
- 實現鏈表的排序功能
- 添加適當的錯誤處理

## 練習 2：二叉樹結構

實現一個二叉搜索樹：

要求：
- 設計二叉樹節點結構（包含左右子樹指針）
- 實現插入、刪除、查找操作
- 實現前序、中序、後序遍歷
- 計算樹的高度和節點數量
- 實現樹的平衡檢查

## 練習 3：內存池管理

創建一個簡單的內存池：

要求：
- 實現對象池模式，重用對象減少 GC 壓力
- 支援不同大小的內存塊分配
- 實現內存池的統計功能（已用、可用、總量）
- 添加內存池的清理和重置功能
- 確保線程安全（使用適當的同步機制）

## 練習 4：圖結構表示

實現圖的鄰接表表示：

要求：
- 設計頂點和邊的結構
- 支援有向圖和無向圖
- 實現添加/刪除頂點和邊的操作
- 實現深度優先搜索（DFS）和廣度優先搜索（BFS）
- 實現最短路徑算法

## 練習 5：LRU 緩存

實現一個 LRU（最近最少使用）緩存：

要求：
- 使用雙向鏈表 + 哈希表實現
- 支援 Get 和 Put 操作
- 當緩存滿時，淘汰最近最少使用的項目
- 實現緩存統計（命中率、miss 次數等）
- 支援緩存大小的動態調整

## 練習 6：函數調用鏈追蹤

創建一個函數調用鏈追蹤工具：

要求：
- 使用指針記錄函數調用棧
- 追蹤函數的進入和退出時間
- 計算函數執行時間
- 支援嵌套函數調用的追蹤
- 生成調用鏈的可視化報告

## 提示

1. 注意指針的初始化和 nil 檢查
2. 合理使用值接收者和指針接收者
3. 考慮內存泄漏和循環引用問題
4. 充分利用 Go 的垃圾回收機制
5. 在操作指針前進行安全檢查
6. 使用適當的數據結構提高效率

## 預期輸出範例

### 練習 1 輸出：
```
=== 雙向鏈表測試 ===
創建空鏈表
鏈表: 空鏈表

插入元素: 1, 2, 3
正向遍歷: 1 <-> 2 <-> 3
反向遍歷: 3 <-> 2 <-> 1

刪除元素 2
正向遍歷: 1 <-> 3

查找元素 3: 找到，地址: 0x1040a128
查找元素 5: 未找到
```

### 練習 2 輸出：
```
=== 二叉搜索樹測試 ===
插入元素: 5, 3, 7, 1, 9, 4, 6

樹結構:
      5
     / \
    3   7
   / \ / \
  1  4 6  9

中序遍歷: 1 3 4 5 6 7 9
前序遍歷: 5 3 1 4 7 6 9
後序遍歷: 1 4 3 6 9 7 5

樹的高度: 3
節點數量: 7
```

### 練習 5 輸出：
```
=== LRU 緩存測試 ===
創建容量為 3 的 LRU 緩存

Put(1, "one")
Put(2, "two") 
Put(3, "three")
緩存狀態: [3:three] <-> [2:two] <-> [1:one]

Get(2): "two" (命中)
緩存狀態: [2:two] <-> [3:three] <-> [1:one]

Put(4, "four") // 淘汰 key=1
緩存狀態: [4:four] <-> [2:two] <-> [3:three]

統計信息:
- 總請求: 4
- 命中: 1
- 命中率: 25.00%
```