# ç¬¬åå…­ç« ï¼šæ–‡ä»¶æ“ä½œ

## ğŸ¯ å­¸ç¿’ç›®æ¨™

- æŒæ¡ Go èªè¨€çš„æ–‡ä»¶è®€å¯«æ“ä½œ
- ç†è§£ä¸åŒçš„æ–‡ä»¶æ“ä½œæ–¹å¼å’Œä½¿ç”¨å ´æ™¯
- å­¸æœƒè™•ç†æ–‡ä»¶æ¬Šé™å’ŒéŒ¯èª¤
- æŒæ¡ç›®éŒ„æ“ä½œå’Œæ–‡ä»¶ç³»çµ±éæ­·
- äº†è§£æ–‡ä»¶ç›£æ§å’Œé«˜ç´šæ–‡ä»¶æ“ä½œ
- å­¸æœƒè™•ç†å¤§æ–‡ä»¶å’Œæµå¼æ“ä½œ
- æŒæ¡æ–‡ä»¶å£“ç¸®å’Œè§£å£“ç¸®

## ğŸ“ æ–‡ä»¶æ“ä½œæ¦‚è¿°

Go èªè¨€æä¾›äº†è±å¯Œçš„æ–‡ä»¶æ“ä½œåŠŸèƒ½ï¼Œä¸»è¦é€šéä»¥ä¸‹åŒ…å¯¦ç¾ï¼š

### æ ¸å¿ƒåŒ…

```
æ–‡ä»¶æ“ä½œç›¸é—œåŒ…ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ os åŒ…                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ åŸºç¤æ–‡ä»¶æ“ä½œ                       â”‚
â”‚ â€¢ æ–‡ä»¶å‰µå»ºã€æ‰“é–‹ã€åˆªé™¤               â”‚
â”‚ â€¢ æ–‡ä»¶æ¬Šé™å’Œå±¬æ€§                     â”‚
â”‚ â€¢ ç›®éŒ„æ“ä½œ                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ io åŒ…                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ é€šç”¨ I/O åŸèª                      â”‚
â”‚ â€¢ Reader/Writer æ¥å£                 â”‚
â”‚ â€¢ è¤‡è£½å’Œç®¡é“æ“ä½œ                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ bufio åŒ…                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ ç·©è¡ I/O æ“ä½œ                      â”‚
â”‚ â€¢ æŒ‰è¡Œè®€å–                          â”‚
â”‚ â€¢ é«˜æ•ˆçš„è®€å¯«                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ filepath åŒ…                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ æ–‡ä»¶è·¯å¾‘æ“ä½œ                       â”‚
â”‚ â€¢ è·¯å¾‘æ‹¼æ¥å’Œæ¸…ç†                     â”‚
â”‚ â€¢ æ¨¡å¼åŒ¹é…                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“– åŸºç¤æ–‡ä»¶æ“ä½œ

### 1. æ–‡ä»¶å‰µå»ºå’Œæ‰“é–‹

```go
import (
    "os"
    "fmt"
)

// å‰µå»ºæ–‡ä»¶
func createFile() {
    // å‰µå»ºæ–°æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨æœƒæˆªæ–·ï¼‰
    file, err := os.Create("example.txt")
    if err != nil {
        panic(err)
    }
    defer file.Close()
    
    // å¯«å…¥å…§å®¹
    file.WriteString("Hello, World!")
}

// æ‰“é–‹æ–‡ä»¶
func openFile() {
    // åªè®€æ¨¡å¼æ‰“é–‹
    file, err := os.Open("example.txt")
    if err != nil {
        panic(err)
    }
    defer file.Close()
    
    // è®€å–å…§å®¹
    data := make([]byte, 100)
    count, err := file.Read(data)
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("è®€å–äº† %d å­—ç¯€: %s\n", count, data[:count])
}

// ä»¥ç‰¹å®šæ¨¡å¼æ‰“é–‹æ–‡ä»¶
func openFileWithFlag() {
    // è®€å¯«æ¨¡å¼ï¼Œå¦‚æœä¸å­˜åœ¨å‰‡å‰µå»º
    file, err := os.OpenFile("example.txt", os.O_RDWR|os.O_CREATE, 0644)
    if err != nil {
        panic(err)
    }
    defer file.Close()
}
```

### 2. æ–‡ä»¶æ¬Šé™å’Œæ¨™èªŒ

```go
// æ–‡ä»¶æ‰“é–‹æ¨™èªŒ
const (
    O_RDONLY int = syscall.O_RDONLY // åªè®€
    O_WRONLY int = syscall.O_WRONLY // åªå¯«
    O_RDWR   int = syscall.O_RDWR   // è®€å¯«
    O_APPEND int = syscall.O_APPEND // è¿½åŠ 
    O_CREATE int = syscall.O_CREAT  // å‰µå»º
    O_EXCL   int = syscall.O_EXCL   // èˆ‡ O_CREATE ä¸€èµ·ä½¿ç”¨ï¼Œæ–‡ä»¶å¿…é ˆä¸å­˜åœ¨
    O_SYNC   int = syscall.O_SYNC   // åŒæ­¥ I/O
    O_TRUNC  int = syscall.O_TRUNC  // æˆªæ–·
)

// æ¬Šé™æ¨¡å¼
const (
    // æ–‡ä»¶æ¬Šé™ï¼ˆUnix é¢¨æ ¼ï¼‰
    ModeDir        = fs.ModeDir        // ç›®éŒ„
    ModeAppend     = fs.ModeAppend     // åªèƒ½è¿½åŠ 
    ModeExclusive  = fs.ModeExclusive  // ç¨å è¨ªå•
    ModeTemporary  = fs.ModeTemporary  // è‡¨æ™‚æ–‡ä»¶
    ModeSymlink    = fs.ModeSymlink    // ç¬¦è™Ÿéˆæ¥
    ModeDevice     = fs.ModeDevice     // è¨­å‚™æ–‡ä»¶
    ModeNamedPipe  = fs.ModeNamedPipe  // å‘½åç®¡é“
    ModeSocket     = fs.ModeSocket     // Unix åŸŸå¥—æ¥å­—
    ModeSetuid     = fs.ModeSetuid     // setuid
    ModeSetgid     = fs.ModeSetgid     // setgid
    ModeCharDevice = fs.ModeCharDevice // å­—ç¬¦è¨­å‚™
    ModeSticky     = fs.ModeSticky     // ç²˜æ»¯ä½
    ModeIrregular  = fs.ModeIrregular  // éå¸¸è¦æ–‡ä»¶
)

// å¸¸ç”¨æ¬Šé™çµ„åˆ
const (
    // æ‰€æœ‰è€…ï¼šè®€å¯«åŸ·è¡Œï¼Œçµ„ï¼šè®€åŸ·è¡Œï¼Œå…¶ä»–ï¼šè®€åŸ·è¡Œ
    FileMode0755 = 0755
    // æ‰€æœ‰è€…ï¼šè®€å¯«ï¼Œçµ„ï¼šè®€ï¼Œå…¶ä»–ï¼šè®€
    FileMode0644 = 0644
    // æ‰€æœ‰è€…ï¼šè®€å¯«åŸ·è¡Œï¼Œçµ„å’Œå…¶ä»–ï¼šç„¡æ¬Šé™
    FileMode0700 = 0700
)
```

## ğŸ“ æ–‡ä»¶è®€å–æ–¹æ³•

### 1. ä¸€æ¬¡æ€§è®€å–æ•´å€‹æ–‡ä»¶

```go
import (
    "io"
    "os"
)

// æ–¹æ³• 1: ä½¿ç”¨ os.ReadFileï¼ˆæ¨è–¦ï¼‰
func readEntireFile1(filename string) ([]byte, error) {
    return os.ReadFile(filename)
}

// æ–¹æ³• 2: ä½¿ç”¨ io.ReadAll
func readEntireFile2(filename string) ([]byte, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, err
    }
    defer file.Close()
    
    return io.ReadAll(file)
}

// ä½¿ç”¨ç¤ºä¾‹
func demonstrateFileReading() {
    // è®€å–æ•´å€‹æ–‡ä»¶
    content, err := os.ReadFile("example.txt")
    if err != nil {
        fmt.Printf("è®€å–æ–‡ä»¶éŒ¯èª¤: %v\n", err)
        return
    }
    
    fmt.Printf("æ–‡ä»¶å…§å®¹: %s\n", string(content))
}
```

### 2. æŒ‰å¡Šè®€å–æ–‡ä»¶

```go
import "bufio"

// æŒ‰å›ºå®šå¤§å°è®€å–
func readFileInChunks(filename string, chunkSize int) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()
    
    buffer := make([]byte, chunkSize)
    for {
        bytesRead, err := file.Read(buffer)
        if err != nil {
            if err == io.EOF {
                break // æ–‡ä»¶çµæŸ
            }
            return err
        }
        
        // è™•ç†è®€å–çš„æ•¸æ“š
        fmt.Printf("è®€å– %d å­—ç¯€: %s\n", bytesRead, string(buffer[:bytesRead]))
    }
    
    return nil
}

// æŒ‰è¡Œè®€å–
func readFileByLines(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()
    
    scanner := bufio.NewScanner(file)
    lineNumber := 1
    
    for scanner.Scan() {
        line := scanner.Text()
        fmt.Printf("è¡Œ %d: %s\n", lineNumber, line)
        lineNumber++
    }
    
    return scanner.Err()
}
```

## âœï¸ æ–‡ä»¶å¯«å…¥æ–¹æ³•

### 1. ä¸€æ¬¡æ€§å¯«å…¥

```go
// æ–¹æ³• 1: ä½¿ç”¨ os.WriteFileï¼ˆæ¨è–¦ï¼‰
func writeEntireFile1(filename string, content []byte) error {
    return os.WriteFile(filename, content, 0644)
}

// æ–¹æ³• 2: ä½¿ç”¨ file.Write
func writeEntireFile2(filename string, content string) error {
    file, err := os.Create(filename)
    if err != nil {
        return err
    }
    defer file.Close()
    
    _, err = file.WriteString(content)
    return err
}
```

### 2. è¿½åŠ å¯«å…¥

```go
// è¿½åŠ å…§å®¹åˆ°æ–‡ä»¶
func appendToFile(filename string, content string) error {
    file, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        return err
    }
    defer file.Close()
    
    _, err = file.WriteString(content)
    return err
}
```

### 3. ç·©è¡å¯«å…¥

```go
// ä½¿ç”¨ç·©è¡å¯«å…¥æé«˜æ€§èƒ½
func bufferedWrite(filename string, lines []string) error {
    file, err := os.Create(filename)
    if err != nil {
        return err
    }
    defer file.Close()
    
    writer := bufio.NewWriter(file)
    defer writer.Flush() // ç¢ºä¿ç·©è¡å€å…§å®¹è¢«å¯«å…¥
    
    for _, line := range lines {
        _, err := writer.WriteString(line + "\n")
        if err != nil {
            return err
        }
    }
    
    return nil
}
```

## ğŸ“‚ ç›®éŒ„æ“ä½œ

### 1. ç›®éŒ„å‰µå»ºå’Œåˆªé™¤

```go
import "path/filepath"

// å‰µå»ºç›®éŒ„
func createDirectory() {
    // å‰µå»ºå–®å€‹ç›®éŒ„
    err := os.Mkdir("testdir", 0755)
    if err != nil {
        fmt.Printf("å‰µå»ºç›®éŒ„éŒ¯èª¤: %v\n", err)
    }
    
    // å‰µå»ºå¤šå±¤ç›®éŒ„
    err = os.MkdirAll("path/to/nested/dir", 0755)
    if err != nil {
        fmt.Printf("å‰µå»ºåµŒå¥—ç›®éŒ„éŒ¯èª¤: %v\n", err)
    }
}

// åˆªé™¤ç›®éŒ„
func removeDirectory() {
    // åˆªé™¤ç©ºç›®éŒ„
    err := os.Remove("testdir")
    if err != nil {
        fmt.Printf("åˆªé™¤ç›®éŒ„éŒ¯èª¤: %v\n", err)
    }
    
    // éæ­¸åˆªé™¤ç›®éŒ„åŠå…¶å…§å®¹
    err = os.RemoveAll("path/to/nested")
    if err != nil {
        fmt.Printf("éæ­¸åˆªé™¤éŒ¯èª¤: %v\n", err)
    }
}
```

### 2. ç›®éŒ„éæ­·

```go
// è®€å–ç›®éŒ„å…§å®¹
func listDirectory(dirPath string) error {
    entries, err := os.ReadDir(dirPath)
    if err != nil {
        return err
    }
    
    for _, entry := range entries {
        info, err := entry.Info()
        if err != nil {
            continue
        }
        
        fmt.Printf("åç¨±: %s, å¤§å°: %d, æ˜¯å¦ç›®éŒ„: %t\n", 
            entry.Name(), info.Size(), entry.IsDir())
    }
    
    return nil
}

// éæ­¸éæ­·ç›®éŒ„
func walkDirectory(root string) error {
    return filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        
        fmt.Printf("è·¯å¾‘: %s, å¤§å°: %d\n", path, info.Size())
        return nil
    })
}
```

## ğŸ” æ–‡ä»¶ä¿¡æ¯å’Œå±¬æ€§

### ç²å–æ–‡ä»¶ä¿¡æ¯

```go
func getFileInfo(filename string) error {
    info, err := os.Stat(filename)
    if err != nil {
        return err
    }
    
    fmt.Printf("æ–‡ä»¶å: %s\n", info.Name())
    fmt.Printf("å¤§å°: %d å­—ç¯€\n", info.Size())
    fmt.Printf("æ¬Šé™: %s\n", info.Mode())
    fmt.Printf("ä¿®æ”¹æ™‚é–“: %s\n", info.ModTime())
    fmt.Printf("æ˜¯å¦ç›®éŒ„: %t\n", info.IsDir())
    
    return nil
}

// æª¢æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
func fileExists(filename string) bool {
    _, err := os.Stat(filename)
    return !os.IsNotExist(err)
}

// æª¢æŸ¥æ˜¯å¦ç‚ºç›®éŒ„
func isDirectory(path string) bool {
    info, err := os.Stat(path)
    if err != nil {
        return false
    }
    return info.IsDir()
}
```

## ğŸš€ é«˜ç´šæ–‡ä»¶æ“ä½œ

### 1. æ–‡ä»¶è¤‡è£½

```go
// è¤‡è£½æ–‡ä»¶
func copyFile(src, dst string) error {
    sourceFile, err := os.Open(src)
    if err != nil {
        return err
    }
    defer sourceFile.Close()
    
    destFile, err := os.Create(dst)
    if err != nil {
        return err
    }
    defer destFile.Close()
    
    _, err = io.Copy(destFile, sourceFile)
    return err
}

// å¸¶é€²åº¦çš„æ–‡ä»¶è¤‡è£½
func copyFileWithProgress(src, dst string) error {
    sourceFile, err := os.Open(src)
    if err != nil {
        return err
    }
    defer sourceFile.Close()
    
    destFile, err := os.Create(dst)
    if err != nil {
        return err
    }
    defer destFile.Close()
    
    // ç²å–æ–‡ä»¶å¤§å°
    fileInfo, _ := sourceFile.Stat()
    fileSize := fileInfo.Size()
    
    // å‰µå»ºé€²åº¦è®€å–å™¨
    progressReader := &ProgressReader{
        reader:   sourceFile,
        total:    fileSize,
        progress: 0,
    }
    
    _, err = io.Copy(destFile, progressReader)
    return err
}

// é€²åº¦è®€å–å™¨
type ProgressReader struct {
    reader   io.Reader
    total    int64
    progress int64
}

func (pr *ProgressReader) Read(p []byte) (int, error) {
    n, err := pr.reader.Read(p)
    pr.progress += int64(n)
    
    // é¡¯ç¤ºé€²åº¦
    if pr.total > 0 {
        percentage := float64(pr.progress) / float64(pr.total) * 100
        fmt.Printf("\rè¤‡è£½é€²åº¦: %.2f%%", percentage)
    }
    
    return n, err
}
```

### 2. æ–‡ä»¶ç›£æ§

```go
import (
    "time"
    "path/filepath"
)

// ç°¡å–®çš„æ–‡ä»¶ç›£æ§
func watchFile(filename string, interval time.Duration) {
    var lastModTime time.Time
    
    // ç²å–åˆå§‹ä¿®æ”¹æ™‚é–“
    if info, err := os.Stat(filename); err == nil {
        lastModTime = info.ModTime()
    }
    
    ticker := time.NewTicker(interval)
    defer ticker.Stop()
    
    for range ticker.C {
        info, err := os.Stat(filename)
        if err != nil {
            continue
        }
        
        if info.ModTime().After(lastModTime) {
            fmt.Printf("æ–‡ä»¶ %s å·²è¢«ä¿®æ”¹\n", filename)
            lastModTime = info.ModTime()
        }
    }
}
```

## ğŸ› ï¸ å¯¦ç”¨å·¥å…·å‡½æ•¸

### æ–‡ä»¶å·¥å…·é›†

```go
package fileutils

import (
    "crypto/md5"
    "encoding/hex"
    "io"
    "os"
    "path/filepath"
    "strings"
)

// FileUtils æ–‡ä»¶å·¥å…·é›†
type FileUtils struct{}

// NewFileUtils å‰µå»ºæ–‡ä»¶å·¥å…·å¯¦ä¾‹
func NewFileUtils() *FileUtils {
    return &FileUtils{}
}

// GetFileExtension ç²å–æ–‡ä»¶æ“´å±•å
func (fu *FileUtils) GetFileExtension(filename string) string {
    return strings.ToLower(filepath.Ext(filename))
}

// GetFileSize ç²å–æ–‡ä»¶å¤§å°
func (fu *FileUtils) GetFileSize(filename string) (int64, error) {
    info, err := os.Stat(filename)
    if err != nil {
        return 0, err
    }
    return info.Size(), nil
}

// CalculateMD5 è¨ˆç®—æ–‡ä»¶ MD5 å€¼
func (fu *FileUtils) CalculateMD5(filename string) (string, error) {
    file, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer file.Close()
    
    hash := md5.New()
    _, err = io.Copy(hash, file)
    if err != nil {
        return "", err
    }
    
    return hex.EncodeToString(hash.Sum(nil)), nil
}

// FindFiles æŸ¥æ‰¾åŒ¹é…æ¨¡å¼çš„æ–‡ä»¶
func (fu *FileUtils) FindFiles(root, pattern string) ([]string, error) {
    var matches []string
    
    err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        
        if matched, _ := filepath.Match(pattern, filepath.Base(path)); matched {
            matches = append(matches, path)
        }
        
        return nil
    })
    
    return matches, err
}
```

## ğŸ¯ æœ€ä½³å¯¦è¸

### 1. éŒ¯èª¤è™•ç†

```go
// å®‰å…¨çš„æ–‡ä»¶æ“ä½œ
func safeFileOperation(filename string) error {
    // æª¢æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    if _, err := os.Stat(filename); os.IsNotExist(err) {
        return fmt.Errorf("æ–‡ä»¶ä¸å­˜åœ¨: %s", filename)
    }
    
    // æª¢æŸ¥æ¬Šé™
    file, err := os.OpenFile(filename, os.O_RDWR, 0)
    if err != nil {
        return fmt.Errorf("ç„¡æ³•æ‰“é–‹æ–‡ä»¶: %w", err)
    }
    defer file.Close()
    
    // é€²è¡Œæ–‡ä»¶æ“ä½œ...
    return nil
}
```

### 2. è³‡æºç®¡ç†

```go
// æ­£ç¢ºçš„è³‡æºç®¡ç†
func properResourceManagement() {
    file, err := os.Open("example.txt")
    if err != nil {
        // è™•ç†éŒ¯èª¤
        return
    }
    defer file.Close() // ç¢ºä¿æ–‡ä»¶è¢«é—œé–‰
    
    // ä½¿ç”¨æ–‡ä»¶...
}
```

### 3. ä¸¦ç™¼å®‰å…¨

```go
import "sync"

// ç·šç¨‹å®‰å…¨çš„æ–‡ä»¶æ“ä½œ
type SafeFileWriter struct {
    filename string
    mutex    sync.Mutex
}

func (sfw *SafeFileWriter) WriteString(content string) error {
    sfw.mutex.Lock()
    defer sfw.mutex.Unlock()
    
    return os.WriteFile(sfw.filename, []byte(content), 0644)
}
```

## ğŸ“‹ å¸¸è¦‹ä½¿ç”¨å ´æ™¯

### 1. é…ç½®æ–‡ä»¶è®€å–
### 2. æ—¥èªŒæ–‡ä»¶å¯«å…¥
### 3. æ•¸æ“šå‚™ä»½å’Œæ¢å¾©
### 4. æ–‡ä»¶æ‰¹é‡è™•ç†
### 5. è‡¨æ™‚æ–‡ä»¶ç®¡ç†

## ğŸš¨ æ³¨æ„äº‹é …

1. **è¨˜ä½é—œé–‰æ–‡ä»¶**ï¼šä½¿ç”¨ `defer file.Close()`
2. **è™•ç†éŒ¯èª¤**ï¼šæ–‡ä»¶æ“ä½œå®¹æ˜“å‡ºéŒ¯ï¼Œè¦å¦¥å–„è™•ç†
3. **æª¢æŸ¥æ¬Šé™**ï¼šç¢ºä¿æœ‰è¶³å¤ çš„æ–‡ä»¶æ¬Šé™
4. **å¤§æ–‡ä»¶è™•ç†**ï¼šå°æ–¼å¤§æ–‡ä»¶ä½¿ç”¨æµå¼è™•ç†
5. **è·¨å¹³å°å…¼å®¹**ï¼šæ³¨æ„ä¸åŒæ“ä½œç³»çµ±çš„è·¯å¾‘å·®ç•°

---

**ä¸‹ä¸€ç« ï¼š[JSON è™•ç†](../17-json-handling/)**